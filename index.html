<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <!-- ★ 追加 -->
    <title>Live2D風 スマホ対応</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #f0f0f0;
      }
      #container {
        width: 100%;
        height: 100%;
        position: relative;
      }
      .follow-img {
        position: absolute;
        width: 100px;
        height: 100px;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      .follow-img-2 {
        position: absolute;
        width: 300px;
        height: auto;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <img id="eye" class="follow-img" src="眼鏡アイコン.png" alt="画像_目" />
      <img id="face" class="follow-img-2" src="サラリーマン.png" alt="画像_顔" />
    </div>

    <script>
      let centerX = window.innerWidth / 2; // 修正: letに変更（後で再代入するため）
      let centerY = window.innerHeight / 2;

      const objects = [
        {
          el: document.getElementById("eye"),
          x: centerX,
          y: centerY,
          targetX: centerX,
          targetY: centerY,
          maxRadius: 30,
          speed: 0.08,
          offsetX: 0,
          offsetY: -40,
        },
        {
          el: document.getElementById("face"),
          x: centerX,
          y: centerY,
          targetX: centerX,
          targetY: centerY,
          maxRadius: 20,
          speed: 0.04,
          offsetX: 0,
          offsetY: 0,
        },
      ];

      function updateTargets(clientX, clientY) {
        for (const obj of objects) {
          const refCenterX = centerX + obj.offsetX;
          const refCenterY = centerY + obj.offsetY;
          const dx = clientX - refCenterX;
          const dy = clientY - refCenterY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist <= obj.maxRadius) {
            obj.targetX = clientX;
            obj.targetY = clientY;
          } else {
            const ratio = obj.maxRadius / dist;
            obj.targetX = refCenterX + dx * ratio;
            obj.targetY = refCenterY + dy * ratio;
          }
        }
      }

      // PC: マウス追従
      document.addEventListener("mousemove", (e) => {
        updateTargets(e.clientX, e.clientY);
      });

      // スマホ: タッチ対応
      document.addEventListener("touchmove", (e) => {
        if (e.touches.length > 0) {
          const touch = e.touches[0];
          updateTargets(touch.clientX, touch.clientY);
        }
      }, { passive: true }); // スクロール抑制を避ける

      function animate() {
        for (const obj of objects) {
          obj.x += (obj.targetX - obj.x) * obj.speed;
          obj.y += (obj.targetY - obj.y) * obj.speed;
          obj.el.style.left = `${obj.x}px`;
          obj.el.style.top = `${obj.y}px`;
        }
        requestAnimationFrame(animate);
      }

      animate();

      function resetPosition() {
        for (const obj of objects) {
          const baseX = centerX + obj.offsetX;
          const baseY = centerY + obj.offsetY;
          obj.x = baseX;
          obj.y = baseY;
          obj.targetX = baseX;
          obj.targetY = baseY;
          obj.el.style.left = `${baseX}px`;
          obj.el.style.top = `${baseY}px`;
        }
      }
      resetPosition();

      window.addEventListener("resize", () => {
        centerX = window.innerWidth / 2;
        centerY = window.innerHeight / 2;
        resetPosition();
      });
    </script>
  </body>
</html>
